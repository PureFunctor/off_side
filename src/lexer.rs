use std::{collections::VecDeque, iter::Peekable};

use pest::{error::Error, iterators::FlatPairs, Parser};

#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct Grammar;

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct Position {
    pub offset: usize,
    pub line: usize,
    pub column: usize,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum TokenKind<'a> {
    UpperName(&'a str),
    LowerName(&'a str),
    SymbolName(&'a str),
    LiteralInteger(&'a str),
    LayoutStart,
    LayoutSeperator,
    LayoutEnd,
    Eof,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct Token<'a> {
    pub kind: TokenKind<'a>,
    pub start: Position,
    pub end: Position,
}

impl<'a> Token<'a> {
    pub fn eof(position: Position) -> Self {
        Self {
            kind: TokenKind::Eof,
            start: position,
            end: position,
        }
    }

    pub fn layout_start(position: Position) -> Self {
        Self {
            kind: TokenKind::LayoutStart,
            start: position,
            end: position,
        }
    }

    pub fn layout_separator(position: Position) -> Self {
        Self {
            kind: TokenKind::LayoutSeperator,
            start: position,
            end: position,
        }
    }

    pub fn layout_end(position: Position) -> Self {
        Self {
            kind: TokenKind::LayoutEnd,
            start: position,
            end: position,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Delimiter {
    Ado,
    Brace,
    Case,
    CaseBinders,
    CaseGuard,
    DeclarationGuard,
    Do,
    Forall,
    LetExpression,
    LetStatement,
    Of,
    Parenthesis,
    Property,
    Root,
    Square,
    TopDeclaration,
    TopDeclarationHead,
    Where,
    If,
    Then,
    LambdaBinders,
}

impl Delimiter {
    pub fn is_indented(&self) -> bool {
        use Delimiter::*;
        matches!(self, Ado | Do | Of | LetExpression | LetStatement | Where)
    }
}

macro_rules! lower_name {
    ($name:pat) => {
        TokenKind::LowerName($name)
    };
}

macro_rules! symbol_name {
    ($name:expr) => {
        TokenKind::SymbolName($name)
    };
}

pub fn lex(source: &str) -> Result<LexWithLayout, Error<Rule>> {
    let pairs = Grammar::parse(Rule::tokens, source)?.flatten().peekable();
    Ok(LexWithLayout::new(source, pairs))
}

/// An iterator over `Token`s which handles layout rules.
pub struct LexWithLayout<'a> {
    /// The contents of the source file being tokenized.
    source: &'a str,
    /// The byte offsets of each line in the source file.
    offsets: Vec<usize>,
    /// An iterator over the token pairs generated by `pest`.
    pairs: Peekable<FlatPairs<'a, Rule>>,
    /// The current token being handled, initially set to `None`.
    current: Option<Token<'a>>,
    /// The current stack of layout delimiters and their positions.
    stack: Vec<(Position, Delimiter)>,
    /// The current queue of tokens to be emitted.
    queue: VecDeque<Token<'a>>,
}

impl<'a> Iterator for LexWithLayout<'a> {
    type Item = Token<'a>;

    /// This particular implementation of `next` is non-linear in that
    /// it first drains the `queue` before actually moving to the next
    /// token. Once empty, it may get filled up again unless `pairs`
    /// is already exhausted. If an `Eof` is encountered while the
    /// `queue` is empty, `LayoutEnd` tokens will get pushed to the
    /// `queue`, and will be yieled at the next iteration.
    fn next(&mut self) -> Option<Self::Item> {
        if self.queue.is_empty() {
            self.next_current()?;
            self.next_with_layout();
            let token = self.queue.pop_back();
            if let Some(Token {
                kind: TokenKind::Eof,
                ..
            }) = token
            {
                self.unwind_layout();
                self.queue.pop_back()
            } else {
                token
            }
        } else {
            self.queue.pop_back()
        }
    }
}

/// Top-level methods.
impl<'a> LexWithLayout<'a> {
    /// Creates a new `LexWithLayout` iterator.
    fn new(source: &'a str, pairs: Peekable<FlatPairs<'a, Rule>>) -> Self {
        let mut offset = 0;
        let mut offsets = vec![];
        for line in source.split('\n') {
            offsets.push(offset);
            offset += line.len() + 1
        }
        let current = None;
        let stack = vec![(
            Position {
                offset: 0,
                line: 1,
                column: 1,
            },
            Delimiter::Root,
        )];
        let queue = VecDeque::new();
        LexWithLayout {
            source,
            offsets,
            pairs,
            current,
            stack,
            queue,
        }
    }

    /// Determines the line and column position of a given byte offset.
    fn get_position(&self, offset: usize) -> Position {
        assert!(
            offset <= self.source.len(),
            "offset cannot be greater than source"
        );

        // Find the closest line offset and its index
        let closest_index = self
            .offsets
            .binary_search_by_key(&offset, |&offset| offset)
            .unwrap_or_else(|index| index.saturating_sub(1));
        let line_offset = self.offsets[closest_index];

        // Determine the line and column numbers
        let line = closest_index + 1;
        let column = offset - line_offset + 1;

        Position {
            offset,
            line,
            column,
        }
    }
}

/// `current_*` and `future_*` methods for querying information about
/// the current and next tokens.
impl<'a> LexWithLayout<'a> {
    /// Get the kind of the current token.
    fn current_kind(&self) -> TokenKind<'a> {
        match self.current {
            Some(current) => current.kind,
            None => panic!("current token is uninitialized"),
        }
    }
    /// Get the start position of the current token.
    fn current_start(&self) -> Position {
        match self.current {
            Some(current) => current.start,
            None => panic!("current token is uninitialized"),
        }
    }
    /// Get the end position of the current token.
    fn current_end(&self) -> Position {
        match self.current {
            Some(current) => current.end,
            None => panic!("current token is uninitialized"),
        }
    }
    /// Get the start position of a future token. Returns the end of
    /// the current token if there's no more future tokens.
    fn future_start(&mut self) -> Position {
        if let Some(future) = self.pairs.peek() {
            let start_offset = future.as_span().start();
            self.get_position(start_offset)
        } else {
            self.current_end()
        }
    }
}

/// Primitive methods for manipulating the token queue and the
/// delimiter stack.
impl<'a> LexWithLayout<'a> {
    /// Pushes a delimiter to the stack at the current token's
    /// position, panicking if it's uninitialized.
    fn push_current_start(&mut self, delimiter: Delimiter) {
        let start = self.current_start();
        self.stack.push((start, delimiter));
    }
    /// Pushes a delimiter to the stack at a future token's position,
    /// using the current token's end position if it does not exist.
    fn push_future_start(&mut self, delimiter: Delimiter) {
        let start = self.future_start();
        self.stack.push((start, delimiter));
    }
    /// Pushes the current token to the queue, panicking if it's
    /// uninitialized.
    fn insert_current(&mut self) {
        match self.current {
            Some(current) => self.queue.push_front(current),
            None => panic!("current token is uninitialized"),
        }
    }
}

/// Core methods for implementing various layout rules.
impl<'a> LexWithLayout<'a> {
    /// Given a predicate, this "removes" elements from the delimiter
    /// stack and "adds" the appropriate amount of `LayoutEnd` tokens
    /// to the queue.
    ///
    /// In practice, this performs no mutable operations and only
    /// returns two things: the new size of the stack to be used
    /// alongside `discard_delimiter_n` and the number of `LayoutEnd`
    /// tokens to be inserted with `queue_n_layout_end`.
    fn collapse<F>(&self, predicate: F) -> (usize, usize)
    where
        F: Fn(&Position, &Delimiter) -> bool,
    {
        let mut take_n = self.stack.len();
        let mut make_n = 0;

        for (position, delimiter) in self.stack.iter().rev() {
            if predicate(position, delimiter) {
                take_n = take_n.saturating_sub(1);
                if delimiter.is_indented() {
                    make_n += 1;
                }
            } else {
                break;
            }
        }

        (take_n, make_n)
    }
    /// Pushes a `LayoutStart` token to the queue and a provided
    /// delimiter to the delimiter stack if a future token is indented
    /// past the most recent delimiter that introduces an indentation
    /// context.
    fn insert_start(&mut self, delimiter: Delimiter) {
        let next = self.future_start();

        let recent_indented = self
            .stack
            .iter()
            .rfind(|(_, delimiter)| delimiter.is_indented());

        if let Some((past, _)) = recent_indented {
            if next.column <= past.column {
                return;
            }
        }

        self.stack.push((next, delimiter));
        self.queue.push_front(Token::layout_start(next));
    }
    /// Pushes a `LayoutSeperator` token to the delimiter stack if
    /// the topmost element introduces an indentation context and
    /// the current token aligns with it.
    fn insert_seperator(&mut self) {
        let token = self.current_start();
        match self.stack.last() {
            Some((position, Delimiter::TopDeclaration | Delimiter::TopDeclarationHead)) => {
                if token.column == position.column && token.line != position.line {
                    self.stack.pop();
                    self.queue.push_front(Token::layout_separator(token));
                }
            }
            Some((position, delimiter)) => {
                if delimiter.is_indented()
                    && token.column == position.column
                    && token.line != position.line
                {
                    self.queue.push_front(Token::layout_separator(token));
                    if let Delimiter::Of = delimiter {
                        self.push_current_start(Delimiter::CaseBinders);
                    }
                }
            }
            _ => {}
        }
    }
    /// Pushes the current token after collapsing the layout.
    fn collapse_and_insert_current(&mut self) {
        let (take_n, make_n) = self.collapse(|position, delimiter| {
            delimiter.is_indented() && self.current_start().column < position.column
        });
        self.stack.truncate(take_n);
        for _ in 0..make_n {
            self.queue
                .push_front(Token::layout_end(self.current_start()));
        }
        self.insert_seperator();
        self.insert_current();
    }
    /// Discards all remaining elements from the layout stack while
    /// pushing the appropriate amount of `LayoutEnd` and `Eof` tokens
    /// to the queue.
    fn unwind_layout(&mut self) {
        let position = self.current_end();
        while let Some((_, delimiter)) = self.stack.pop() {
            if let Delimiter::Root = delimiter {
                self.queue.push_front(Token::eof(position));
            } else if delimiter.is_indented() {
                self.queue.push_front(Token::layout_end(position));
            }
        }
    }
}

/// Driver methods for advancing the current state.
impl<'a> LexWithLayout<'a> {
    /// Updates the current token by advancing the internal pairs
    /// iterator, returning an `Option` for easier short-circuiting.
    fn next_current(&mut self) -> Option<()> {
        use TokenKind::*;

        let pair = self.pairs.next()?;
        let rule = pair.as_rule();
        let span = pair.as_span();
        let slice = pair.as_str();
        self.current = Some(Token {
            kind: match rule {
                Rule::upper_name => UpperName(slice),
                Rule::lower_name => LowerName(slice),
                Rule::symbol_name => SymbolName(slice),
                Rule::digit_value => LiteralInteger(slice),
                Rule::paren_name => SymbolName(slice),
                Rule::EOI => Eof,
                rule => unreachable!("unhandled rule {:?}", rule),
            },
            start: self.get_position(span.start()),
            end: self.get_position(span.end()),
        });

        Some(())
    }
    /// Pushes the current token to the queue with respect to layout
    /// rules in the language.
    fn next_with_layout(&mut self) {
        use Delimiter::*;

        // a convenience macro that pattern matches against the result
        // of a `collapse`, making sure that the required post-collapse
        // operations are run before doing anything else.
        //
        // the boolean `commit` determines whether or not to mutate
        // the delimiter stack and the token queue.
        macro_rules! collapse {
            ($predicate:expr, $($commit:literal ~ $pattern:pat $(if $guard:expr)? => $expression:expr,)+) => {
                {
                    let (stack_n, layout_m) = self.collapse($predicate);
                    match &self.stack[..stack_n] {
                        $($pattern $(if $guard)? => {
                            if $commit {
                                self.stack.truncate(stack_n);
                                for _ in 0..layout_m {
                                    self.queue.push_front(Token::layout_end(self.current_start()));
                                }
                            };
                            $expression
                        }),+
                    }
                }
            };
        }

        macro_rules! insert_keyword {
            ($else:expr) => {
                match self.stack.last() {
                    Some((_, Property)) => {
                        self.stack.pop();
                        self.insert_current();
                    }
                    _ => $else,
                }
            };
        }

        macro_rules! pop_match {
            ($pattern:pat) => {
                if let Some((_, $pattern)) = self.stack.last() {
                    self.stack.pop();
                }
            };
        }

        match self.current_kind() {
            lower_name!("data") => insert_keyword!({
                self.collapse_and_insert_current();
                if let [(_, Root), (_, Where)] = &self.stack[..] {
                    self.push_current_start(TopDeclaration);
                }
            }),
            lower_name!("class") => insert_keyword!({
                self.collapse_and_insert_current();
                if let [(_, Root), (_, Where)] = &self.stack[..] {
                    self.push_current_start(TopDeclarationHead);
                }
            }),
            lower_name!("forall") => insert_keyword!({
                self.insert_current();
                self.push_current_start(Forall);
            }),
            lower_name!("let") => insert_keyword!({
                self.collapse_and_insert_current();

                let delimiter = match self.stack.last() {
                    Some((position, Do | Ado))
                        if self.current_start().column == position.column =>
                    {
                        LetStatement
                    }
                    _ => LetExpression,
                };

                self.insert_start(delimiter);
            }),
            lower_name!("where") => insert_keyword!({
                match self.stack.last() {
                    Some((_, TopDeclarationHead)) => {
                        self.insert_current();
                        self.insert_start(Where);
                    }
                    _ => {
                        collapse!(
                            |position, delimiter| {
                                matches!(delimiter, Do) ||
                                    ( delimiter.is_indented() &&
                                      self.current_start().column <= position.column
                                    )
                            },
                            true ~ _ => {
                                self.insert_current();
                                self.insert_start(Where);
                            },
                        );
                    }
                }
            }),
            lower_name!("do") => insert_keyword!({
                self.collapse_and_insert_current();
                self.insert_start(Do);
            }),
            lower_name!("ado") => insert_keyword!({
                self.collapse_and_insert_current();
                self.insert_start(Ado);
            }),
            lower_name!("in") => {
                collapse!(
                    // collapse delimiters that introduce an indented
                    // context until we find `Ado` or `LetExpression`,
                    // since we manually handle them below.
                    |_, delimiter| match delimiter {
                        Ado | LetExpression => false,
                        _ => delimiter.is_indented(),
                    },

                    // this is encountered when a `LetExpression` is
                    // used inside of a `LetStatement` in an `Ado`
                    // block.
                    //
                    // ```hs
                    // test = ado
                    //   let a = let b = c in c
                    //   in a
                    // ```
                    //
                    // into:
                    //
                    // ```hs
                    // test = ado{
                    //   let {a = let {b = c} in c}}
                    //   in a
                    // ```
                    true ~ [.., (_, Ado), (_, LetStatement)] => {
                        self.stack.pop();
                        self.stack.pop();
                        self.queue.push_front(Token::layout_end(self.current_start()));
                        self.queue.push_front(Token::layout_end(self.current_start()));
                        self.insert_current();
                    },

                    // this is a fallthrough for all other delimiters
                    // that have to be collapsed, such as a
                    // `LetExpression`.
                    true ~ [.., (_, delimiter)] if delimiter.is_indented() => {
                        self.stack.pop();
                        self.queue.push_front(Token::layout_end(self.current_start()));
                        self.insert_current();
                    },

                    // if there's no more delimiters to be collapsed,
                    // we just run the default insertion operations
                    // and remove `Property` if we're inside record
                    // syntax.
                    false ~ _ => insert_keyword!({
                        self.collapse_and_insert_current();
                    }),
                );
            }
            lower_name!("case") => insert_keyword!({
                self.collapse_and_insert_current();
                self.push_current_start(Case);
            }),
            lower_name!("of") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ [.., (_, Case)] => {
                        self.stack.pop();
                        self.insert_current();
                        self.insert_start(Of);
                        self.push_future_start(CaseBinders);
                    },
                    true ~ _ => insert_keyword!({
                        self.collapse_and_insert_current();
                    }),
                )
            }
            lower_name!("if") => insert_keyword!({
                self.collapse_and_insert_current();
                self.push_current_start(If);
            }),
            lower_name!("then") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ [.., (_, If)] => {
                        self.stack.pop();
                        self.insert_current();
                        self.push_current_start(Then);
                    },
                    false ~ _ => insert_keyword!({
                        self.collapse_and_insert_current();
                    }),
                )
            }
            lower_name!("else") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ [.., (_, Then)] => {
                        self.stack.pop();
                        self.insert_current();
                    },
                    false ~ _ => {
                        collapse!(
                            |position, delimiter| {
                                delimiter.is_indented() && self.current_start().column < position.column
                            },
                            true ~ [(_, Root), (_, Where)] => {
                                self.insert_current();
                            },
                            true ~ _ => {
                                self.insert_seperator();
                                insert_keyword!({
                                    self.insert_current();
                                });
                            },
                        )
                    },
                );
            }
            symbol_name!("|") => {
                collapse!(
                    |position, delimiter| {
                        delimiter.is_indented() && self.current_start().column <= position.column
                    },
                    true ~ [.., (_, Of)] => {
                        self.push_future_start(CaseGuard);
                        self.insert_current();
                    },
                    true ~ [.., (_, LetExpression | LetStatement | Where)] => {
                        self.push_future_start(DeclarationGuard);
                        self.insert_current();
                    },
                    true ~ _ => insert_keyword!({
                        self.collapse_and_insert_current();
                    }),
                );
            }
            symbol_name!("->") => {
                collapse!(
                    |position, delimiter| match delimiter {
                        Do => true,
                        Of => false,
                        _ => delimiter.is_indented() && self.current_start().column <= position.column,
                    },
                    true ~ _ => {
                        self.insert_current();
                        pop_match!(CaseGuard | CaseBinders | LambdaBinders);
                    },
                );
            }
            symbol_name!("=") => {
                collapse!(
                    |_, delimiter| matches!(delimiter, LetExpression | LetStatement | Where),
                    true ~ [.., (_, DeclarationGuard)] => {
                        self.stack.pop();
                        self.insert_current();
                    },
                    false ~ _ => {
                        self.collapse_and_insert_current();
                    },
                );
            }
            symbol_name!(",") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ _ => {
                        self.insert_current();
                        if let Some((_, Brace)) = self.stack.last() {
                            self.push_current_start(Property);
                        }
                    },
                );
            }
            symbol_name!(".") => {
                self.collapse_and_insert_current();
                if let Some((_, Forall)) = self.stack.last() {
                    self.stack.pop();
                } else {
                    self.push_current_start(Property);
                }
            }
            symbol_name!("\\") => {
                self.collapse_and_insert_current();
                self.push_current_start(LambdaBinders);
            }
            symbol_name!("[") => {
                self.collapse_and_insert_current();
                self.push_current_start(Square);
            }
            symbol_name!("]") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ _ => {
                        self.insert_current();
                        pop_match!(Square);
                    },
                );
            }
            symbol_name!("(") => {
                self.collapse_and_insert_current();
                self.push_current_start(Parenthesis);
            }
            symbol_name!(")") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ _ => {
                        self.insert_current();
                        pop_match!(Parenthesis);
                    },
                );
            }
            symbol_name!("{") => {
                self.collapse_and_insert_current();
                self.push_current_start(Brace);
                self.push_current_start(Property);
            }
            symbol_name!("}") => {
                collapse!(
                    |_, delimiter| delimiter.is_indented(),
                    true ~ _ => {
                        self.insert_current();
                        pop_match!(Property);
                        pop_match!(Brace);
                    },
                );
            }
            lower_name!(_) => {
                self.collapse_and_insert_current();
                pop_match!(Property);
            }
            _ => {
                self.collapse_and_insert_current();
            }
        }
    }
}
