use std::{collections::VecDeque, iter::Peekable};

use pest::{error::Error, iterators::FlatPairs, Parser};

#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct Grammar;

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct Position {
    pub offset: usize,
    pub line: usize,
    pub column: usize,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum TokenKind<'a> {
    UpperName(&'a str),
    LowerName(&'a str),
    SymbolName(&'a str),
    LiteralInteger(&'a str),
    LayoutStart,
    LayoutSeperator,
    LayoutEnd,
    Eof,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct Token<'a> {
    pub kind: TokenKind<'a>,
    pub start: Position,
    pub end: Position,
}

impl<'a> Token<'a> {
    pub fn eof(position: Position) -> Self {
        Self {
            kind: TokenKind::Eof,
            start: position,
            end: position,
        }
    }

    pub fn layout_start(position: Position) -> Self {
        Self {
            kind: TokenKind::LayoutStart,
            start: position,
            end: position,
        }
    }

    pub fn layout_separator(position: Position) -> Self {
        Self {
            kind: TokenKind::LayoutSeperator,
            start: position,
            end: position,
        }
    }

    pub fn layout_end(position: Position) -> Self {
        Self {
            kind: TokenKind::LayoutEnd,
            start: position,
            end: position,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Delimiter {
    Ado,
    Case,
    CaseBinders,
    CaseGuard,
    Do,
    LetExpression,
    LetStatement,
    Of,
    Root,
    Top,
    Where,
}

impl Delimiter {
    fn is_do(&self) -> bool {
        use Delimiter::*;
        matches!(self, Do)
    }

    pub fn is_indented(&self) -> bool {
        use Delimiter::*;

        match self {
            Root | Top | Case | CaseBinders | CaseGuard => false,
            LetExpression | LetStatement | Where | Do | Ado | Of => true,
        }
    }
}

macro_rules! lower_name {
    ($name:expr) => {
        TokenKind::LowerName($name)
    };
}

macro_rules! symbol_name {
    ($name:expr) => {
        TokenKind::SymbolName($name)
    };
}

pub fn lex<'a>(source: &'a str) -> Result<LexWithLayout<'a>, Error<Rule>> {
    let pairs = Grammar::parse(Rule::tokens, source)?.flatten().peekable();
    Ok(LexWithLayout::new(source, pairs))
}

/// An iterator over `Token`s which handles layout rules.
pub struct LexWithLayout<'a> {
    /// The contents of the source file being tokenized.
    source: &'a str,
    /// The byte offsets of each line in the source file.
    offsets: Vec<usize>,
    /// An iterator over the token pairs generated by `pest`.
    pairs: Peekable<FlatPairs<'a, Rule>>,
    /// The current token being handled, initially set to `None`.
    current: Option<Token<'a>>,
    /// The current stack of layout delimiters and their positions.
    stack: Vec<(Position, Delimiter)>,
    /// The current queue of tokens to be emitted.
    queue: VecDeque<Token<'a>>,
}

impl<'a> LexWithLayout<'a> {
    /// Creates a new iterator given the `source` and the `pairs`.
    pub fn new(source: &'a str, pairs: Peekable<FlatPairs<'a, Rule>>) -> Self {
        let mut offset = 0;
        let mut offsets = vec![];
        for line in source.split('\n') {
            offsets.push(offset);
            offset += line.len() + 1
        }
        let current = None;
        let stack = vec![(
            Position {
                offset: 0,
                line: 1,
                column: 1,
            },
            Delimiter::Root,
        )];
        let queue = VecDeque::new();
        LexWithLayout {
            source,
            offsets,
            pairs,
            current,
            stack,
            queue,
        }
    }

    /// Determines the line and column position of a given byte offset.
    pub fn get_position(&self, offset: usize) -> Position {
        if offset > self.source.len() {
            panic!("offset is greater than the source")
        }

        // Find the closest line offset and its index
        let closest_index = self
            .offsets
            .binary_search_by_key(&offset, |&offset| offset)
            .unwrap_or_else(|index| index.saturating_sub(1));
        let line_offset = self.offsets[closest_index];

        // Determine the line and column numbers
        let line = closest_index + 1;
        let column = offset - line_offset + 1;

        Position {
            offset,
            line,
            column,
        }
    }

    fn current_kind(&self) -> TokenKind<'a> {
        self.current.expect("initialized").kind
    }

    fn current_start(&self) -> Position {
        self.current.expect("initialized").start
    }

    fn current_end(&self) -> Position {
        self.current.expect("initialized").end
    }

    /// Updates the `current` token in the state.
    fn next_current(&mut self) -> Option<()> {
        use TokenKind::*;

        let pair = self.pairs.next()?;
        let rule = pair.as_rule();
        let span = pair.as_span();
        let slice = pair.as_str();
        self.current = Some(Token {
            kind: match rule {
                Rule::upper_name => UpperName(slice),
                Rule::lower_name => LowerName(slice),
                Rule::symbol_name => SymbolName(slice),
                Rule::digit_value => LiteralInteger(slice),
                Rule::EOI => Eof,
                rule => unreachable!("unhandled rule {:?}", rule),
            },
            start: self.get_position(span.start()),
            end: self.get_position(span.end()),
        });

        Some(())
    }

    /// Updates the `queue` with layout tokens.
    fn next_layout(&mut self) {
        use Delimiter::*;

        match self.current_kind() {
            lower_name!("let") => {
                self.collapse_offside();
                self.insert_seperator();
                self.queue_up_current();
                let delimiter = match self.stack.last() {
                    Some((position, Do | Ado))
                        if position.column == self.current_start().column =>
                    {
                        LetStatement
                    }
                    _ => LetExpression,
                };
                self.insert_start(delimiter);
            }
            lower_name!("where") => {
                self.collapse_where();
                self.queue_up_current();
                self.insert_start(Where);
            }
            lower_name!("do") => {
                self.queue_up_current();
                self.insert_start(Do);
            }
            lower_name!("ado") => {
                self.queue_up_current();
                self.insert_start(Ado);
            }
            lower_name!("in") => {
                let (take_n, make_n) = self.collapse(|_, delimiter| match delimiter {
                    Ado | LetExpression => false,
                    _ => delimiter.is_indented(),
                });

                match &self.stack[..take_n] {
                    [.., (_, Ado), (_, LetStatement)] => {
                        self.truncate_layouts(take_n.saturating_sub(2));
                        self.push_layout_ends(make_n + 2);
                    }
                    [.., (_, delimiter)] if delimiter.is_indented() => {
                        self.truncate_layouts(take_n.saturating_sub(1));
                        self.push_layout_ends(make_n + 1);
                    }
                    _ => {
                        self.collapse_offside();
                        self.insert_seperator();
                    }
                }
                self.queue_up_current();
            }
            lower_name!("case") => {
                self.collapse_offside();
                self.insert_seperator();
                self.queue_up_current();
                let next = self.next_position();
                self.stack.push((next, Case));
            }
            lower_name!("of") => {
                let (take_n, make_n) = self.collapse(|_, delimiter| delimiter.is_indented());

                match &self.stack[..take_n] {
                    [.., (_, Case)] => {
                        self.truncate_layouts(take_n);
                        self.push_layout_ends(make_n);
                        self.queue_up_current();
                        self.insert_start(Of);
                        let next = self.next_position();
                        self.stack.push((next, CaseBinders));
                    }
                    _ => {
                        self.truncate_layouts(take_n);
                        self.push_layout_ends(make_n);
                        self.collapse_offside();
                        self.insert_seperator();
                        self.queue_up_current();
                    }
                }
            }
            symbol_name!("|") => {
                let token = self.current_start();
                let (stack_end, end_count) = self.collapse(|position, delimiter| {
                    delimiter.is_indented() && token.column <= position.column
                });

                match &self.stack[..stack_end] {
                    [.., (_, Of)] => {
                        self.truncate_layouts(stack_end);
                        self.push_layout_ends(end_count);
                        self.stack.push((token, CaseGuard));
                        self.queue_up_current();
                    }
                    _ => {
                        self.truncate_layouts(stack_end);
                        self.push_layout_ends(end_count);
                        self.collapse_offside();
                        self.insert_seperator();
                        self.queue_up_current();
                    }
                }
            }
            symbol_name!("->") => {
                let token = self.current_start();
                self.collapse_and_commit(|position, delimiter| match delimiter {
                    Do => true,
                    Of => false,
                    _ => delimiter.is_indented() && token.column <= position.column,
                });
                loop {
                    match self.stack.last() {
                        Some((_, CaseGuard | CaseBinders)) => {
                            self.stack.pop();
                        }
                        _ => break,
                    }
                }
                self.queue_up_current();
            }
            _ => {
                self.collapse_offside();
                self.insert_seperator();
                self.queue_up_current();
            }
        }
    }

    /// Pushes the current token to the queue.
    fn queue_up_current(&mut self) {
        self.queue.push_front(self.current.expect("initialized"));
    }

    /// Determines the length that the stack should truncate to and
    /// the number of `LayoutEnd` tokens to be pushed to the queue,
    /// given a predicate.
    fn collapse<F>(&self, predicate: F) -> (usize, usize)
    where
        F: Fn(&Position, &Delimiter) -> bool,
    {
        let mut take_n = self.stack.len();
        let mut make_n = 0;

        for (position, delimiter) in self.stack.iter().rev() {
            if predicate(position, delimiter) {
                take_n = take_n.saturating_sub(1);
                make_n += 1;
            } else {
                break;
            }
        }

        (take_n, make_n)
    }

    /// Truncate the layout stack to a specific index.
    fn truncate_layouts(&mut self, take_n: usize) {
        self.stack.truncate(take_n);
    }

    /// Push multiple `LayoutEnd` tokens to the queue.
    fn push_layout_ends(&mut self, make_n: usize) {
        let start = self.current_start();
        for _ in 0..make_n {
            self.queue.push_front(Token::layout_end(start))
        }
    }

    /// Run `collapse` and commit the changes.
    fn collapse_and_commit<F>(&mut self, predicate: F)
    where
        F: Fn(&Position, &Delimiter) -> bool,
    {
        let (take_n, make_n) = self.collapse(predicate);
        self.truncate_layouts(take_n);
        self.push_layout_ends(make_n);
    }

    /// Pops indented delimiters from the layout stack if the current
    /// token is dedented past them.
    ///
    /// # Example
    ///
    /// ```hs
    /// main = do
    ///   logShow "Hello, World."
    ///
    /// meaning_of_life = 42
    /// ```
    ///
    /// The `meaning_of_life` token is dedented past the column that
    /// the `do` delimiter defines as part of its layout, hence, a
    /// `LayoutEnd` token is inserted.
    fn collapse_offside(&mut self) {
        let column = self.current_start().column;
        self.collapse_and_commit(|position, delimiter| {
            delimiter.is_indented() && column < position.column
        });
    }

    /// Pops `do` delimiters from the layout stack or indented
    /// delimiters if the current token is dedented past them.
    ///
    /// # Example
    ///
    /// `where` always ends `do` blocks.
    ///
    /// ```hs
    /// main = do do do do where foo = ...
    /// ```
    fn collapse_where(&mut self) {
        let column = self.current_start().column;
        self.collapse_and_commit(|position, delimiter| {
            delimiter.is_do() || (delimiter.is_indented() && column <= position.column)
        })
    }

    fn next_position(&mut self) -> Position {
        let next_offset = match self.pairs.peek() {
            Some(next) => next.as_span().start(),
            None => self.current_end().offset,
        };

        self.get_position(next_offset)
    }

    /// Inserts a `LayoutStart` token and pushes a delimiter to the
    /// layout stack if the next token is indented past the latest
    /// delimiter.
    fn insert_start(&mut self, delimiter: Delimiter) {
        let next = self.next_position();

        let past_indented = self
            .stack
            .iter()
            .rfind(|(_, delimiter)| delimiter.is_indented());

        if let Some((past, _)) = past_indented {
            if next.column <= past.column {
                return;
            }
        }

        self.stack.push((next, delimiter));
        self.queue.push_front(Token {
            kind: TokenKind::LayoutStart,
            start: next,
            end: next,
        });
    }

    /// Inserts a `LayoutSeperator` token if the top of the layout
    /// stack is indented, and the current token matches with the
    /// delimiter's expected column.
    fn insert_seperator(&mut self) {
        let token = self.current_start();
        match self.stack.last() {
            Some((position, Delimiter::Top)) => {
                if token.column == position.column && token.line != position.line {
                    self.stack.pop();
                    self.queue.push_front(Token::layout_separator(token));
                }
            }
            Some((position, delimiter)) => {
                if delimiter.is_indented()
                    && token.column == position.column
                    && token.line != position.line
                {
                    self.queue.push_front(Token::layout_separator(token));
                    if let Delimiter::Of = delimiter {
                        self.stack.push((token, Delimiter::CaseBinders));
                    }
                }
            }
            _ => {}
        }
    }

    /// Removes all remaining delimiters in the layout stack and
    /// pushes the appropriate amount for `LayoutEnd` tokens and an
    /// `Eof` token.
    fn unwind_layout(&mut self) {
        let position = self.current_end();
        while let Some((_, delimiter)) = self.stack.pop() {
            if let Delimiter::Root = delimiter {
                self.queue.push_front(Token::eof(position));
            } else if delimiter.is_indented() {
                self.queue.push_front(Token::layout_end(position));
            }
        }
    }
}

impl<'a> Iterator for LexWithLayout<'a> {
    type Item = Token<'a>;

    /// This particular implementation of `next` is non-linear in that
    /// it first drains the `queue` before actually moving to the next
    /// token. Once empty, it may get filled up again unless `pairs`
    /// is already exhausted. If an `Eof` is encountered while the
    /// `queue` is empty, `LayoutEnd` tokens will get pushed to the
    /// `queue`, and will be yieled at the next iteration.
    fn next(&mut self) -> Option<Self::Item> {
        if self.queue.is_empty() {
            self.next_current()?;
            self.next_layout();
            let token = self.queue.pop_back();
            if let Some(Token {
                kind: TokenKind::Eof,
                ..
            }) = token
            {
                self.unwind_layout();
                self.queue.pop_back()
            } else {
                token
            }
        } else {
            self.queue.pop_back()
        }
    }
}
